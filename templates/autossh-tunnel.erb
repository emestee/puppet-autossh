#!/bin/sh
### BEGIN INIT INFO
# Provides:          autossh-tunnel-<%= @name %>
# Required-Start:    $local_fs $remote_fs $network
# Required-Stop:     $local_fs $remote_fs $network
# Should-Start:      $syslog
# Should-Stop:       $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Autossh tunnel <%= @name %>
# Description:       Maintain an SSH tunnel between two hosts.
### END INIT INFO

## !!! THIS SCRIPT IS GENERATED BY PUPPET; DO NOT EDIT MANUALLY !!!

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
USERNAME=<%= @user %>

DESC="secure tunnel"
NAME=autossh-tunnel-<%= @name %>
REAL_NAME=autossh
DAEMON="$(which ${REAL_NAME})"
PIDFILE="/var/run/autossh-tunnel-<%= @name %>.pid"
SCRIPTNAME=/etc/init.d/$NAME

. /lib/lsb/init-functions

#
# AutoSSH configuration
#
AUTOSSH_ARGS="-f -M <%= @real_monitor_port %> -N -L <%= @bind_address %>:<%= @port %>:<%= @host %>:<%= @hostport %> <%= @ssh_extra_options %> <%= @real_remote_user %>@<%= @remote_host %> <%= @ssh_remote_port %>"
<% if @gatetime != 'absent' -%>
AUTOSSH_GATETIME=<%= @gatetime %>
<% end -%>
<% if @first_poll != 'absent' -%>
AUTOSSH_FIRST_POLL=<%= @first_poll %>
<% end -%>
<% if @poll != 'absent' -%>
AUTOSSH_POLL=<%= @poll %>
<% end -%>
<% if @maxstart != 'absent' -%>
AUTOSSH_MAXSTART=<%= @maxstart %>
<% end -%>
<% if @maxlifetime != 'absent' -%>
AUTOSSH_MAXLIFETIME=<%= @maxlifetime %>
<% end -%>
<% if @logfile != 'absent' -%>
AUTOSSH_LOGFILE=<%= @logfile %>
<% end -%>

# Exit if the package is not installed
[ -x "${DAEMON}" ] || {
    echo "Autossh is not installed"
    exit 5
}

#
# Function that starts the daemon/service
# 
# Returns:
# - 0 if the daemon has been started successfuly 
# - 1 if the daemon is already running
# - 2 if the daemon failed to start
# - 3 if the daemon is unable to start ssh because ssh's own arguments are invalid
do_start()
{
    export AUTOSSH_PIDFILE="${PIDFILE}"

    # Export the autossh configuration
    if [ -n "$AUTOSSH_GATETIME" ]; then
          export AUTOSSH_GATETIME
    fi
    if [ -n "$AUTOSSH_FIRST_POLL" ]; then
          export AUTOSSH_FIRST_POLL
    fi
    if [ -n "$AUTOSSH_POLL" ]; then
          export AUTOSSH_POLL
    fi
    if [ -n "$AUTOSSH_MAXSTART" ]; then
          export AUTOSSH_MAXSTART
    fi
    if [ -n "$AUTOSSH_MAXLIFETIME" ]; then
          export AUTOSSH_MAXLIFETIME
    fi
    if [ -n "$AUTOSSH_LOGFILE" ]; then
          export AUTOSSH_LOGFILE
    fi

    pidofproc -p "$PIDFILE" "$DAEMON" >/dev/null && return 1

    # LSB start_daemon doesn't guarantee that the pidfile is created. As autossh is executed
    # under the target UID, it won't be able to create the pidfile on RHEL
    touch $PIDFILE
    chown $USERNAME $PIDFILE


    <% if @osfamily == 'Debian' -%>
    start-stop-daemon -p "${PIDFILE}" -u "${USERNAME}" --start --exec ${DAEMON} -- ${AUTOSSH_ARGS} || return 2
    <% else -%>
    start_daemon -u "${USERNAME}" -p "$PIDFILE" "$DAEMON" "$AUTOSSH_ARGS" || return 2
    <% end -%>

    # if autossh was started but bad arguments were passed to ssh, autossh will 
    # return 0 but exit after a few seconds, so we wait just a bit to make sure
    # everything is ok
    sleep 5
    pidofproc -p "$PIDFILE" "$DAEMON" >/dev/null || return 3

    return 0
}

#
# Function that stops the daemon/service
# Returns:
# 0 if the daemon was stopped, or is not running
# LSB exit codes otherwise 
do_stop()
{
    killproc -p $PIDFILE $DAEMON
}

case "$1" in
  start)
        do_start
        case "$?" in
                0) log_success_msg "The tunnel has been started" ; exit 0 ;;
                1) log_success_msg "The tunnel is already running" ; exit 0 ;;
                2) log_failure_msg "Autossh failed to start" ; exit 1 ;;
                3) log_failure_msg "The child ssh client failed to start (options invalid?)" ; exit 1 ;;
                *) log_failure_msg "Unknown failure" ; exit 1 ;; 
        esac
        ;;
  stop)
        do_stop
        case "$?" in
                0) log_success_msg "The tunnel has been stopped" ; exit 0 ;;
                *) log_failure_msg "Unable to stop the tunnel" ; exit 1 ;;
        esac
        ;;
  restart|force-reload)
        #
        # If the "reload" option is implemented then remove the
        # 'force-reload' alias
        #
        do_stop

        [ $? -eq 0 ] || {
            log_failure_msg "Unable to stop the tunnel" 
            exit 1
        }

        do_start
        case "$?" in
                0) log_success_msg "The tunnel has been started" ; exit 0 ;;
                1) log_success_msg "The is already running" ; exit 0 ;;
                2) log_failure_msg "Autossh failed to start" ; exit 1 ;;
                3) log_failure_msg "The child ssh client failed to start (options invalid?)" ; exit 1 ;;
                *) log_failure_msg "Unknown failure" ; exit 1 ;; 
        esac
        ;;
  status)
        
        pidofproc -p "$PIDFILE" "$DAEMON" > /dev/null
        rc=$?
        case "$rc" in 
            0) log_success_msg "The tunnel is up" ;;
            *) log_failure_msg "The tunnel is down" ;;
        esac
        exit $rc
        ;;
  *)
        echo "Usage: $SCRIPTNAME {start|stop|restart|force-reload|status}" >&2
        exit 3
        ;;
esac
